
@InProceedings{ABC01,
  author   = {N. Abraham and U. Bibel and P. Corleone},
  title    = {Formatting Contributions for Proceedings},
  pages    = {46-53},
  crossref = {Gl01},
}

@InBook{Az09,
  pages    = {135-162},
  title    = {Die Fußnote in LNI-Bänden},
  author   = {Azubi, L. and others},
  crossref = {Gl09},
}

@Book{AB00,
  title     = {Formatierungsrichtlinien für Tagungsbände},
  publisher = {Format-Verlag},
  year      = {2000},
  author    = {K. Abel and U. Bibel},
  address   = {Bonn},
}

@Book{Ez10,
  title     = {The Magic Format -- Your Way to Pretty Books},
  publisher = {Noah \& Sons},
  year      = {2010},
  author    = {O. Ezgarani},
}

@Article{Gl06,
  author  = {H. I. Glück},
  title   = {Formatierung leicht gemacht},
  journal = {Formatierungsjournal},
  volume  = {11},
  number  = {09},
  year    = {2009},
  pages   = {23-27},
}

@Book{Wa14,
  title     = {Essenzen der Informatik},
  publisher = {Verlag Formvoll},
  year      = {2014},
  author    = {K. Wasser and H. Feuer and R. Erde and H. Licht},
}

@Book{Wa14b,
  title     = {Ganz neue Essenzen der Informatik im selben Jahr},
  publisher = {Format-Verlag},
  year      = {2014},
  author    = {K. Wasser and H. Feuer and R. Erde and H. Licht},
}

@Proceedings{Gl01,
  title     = {Proc. 7th Int. Conf. on Formatting of Workshop-Proceedings},
  year      = {2001},
  editor    = {Glück, H. I.},
  address   = {San Francisco},
  publisher = {Noah \& Sons},
  booktitle = {Proc. 7th Int. Conf. on Formatting of Workshop-Proceedings},
}

@Book{Gl09,
  title     = {Formatierung 2009},
  publisher = {Format-Verlag},
  year      = {2009},
  editor    = {H. I. Glück},
  number    = {999},
  series    = {LNI},
  address   = {Bonn},
  booktitle = {Formatierung 2009},
}

@Misc{XX14,
  title        = {Anteil an Frauen in der Informatik},
  label        = {An},
  howpublished = {Statistics Worldwide},
  year         = {2014},
}

@Online{GI19,
  author = {{Gesellschaft für Informatik e.\,V.}},
  label  = {GI},
  year  = {2019},
  url  =  {http://www.gi.de},
  urldate = {2019-03-21}
}

@Comment{jabref-meta: databaseType:biblatex;}



% This file was created with Citavi 6.10.0.0

@misc{.04.11.2022,
 abstract = {SourceForge provides free {\&} fast open source software downloads and development, and business software reviews and comparisons featuring the largest open source and business software directory.},
 year = {04.11.2022},
 title = {Compare, Download {\&} Develop Open Source {\&} Business Software - SourceForge},
 url = {https://sourceforge.net/},
 urldate = {04.11.2022}
}


@misc{GitHub.04.11.2022,
 abstract = {GitHub is where over 83 million developers shape the future of software, together. Contribute to the open source community, manage your Git repositories, review code like a pro, track bugs and features, power your CI/CD and DevOps workflows, and secure code before you commit it.},
 author = {GitHub},
 year = {04.11.2022},
 title = {GitHub: Let's build from here},
 url = {https://github.com/},
 urldate = {04.11.2022}
}


@book{NATO.1968,
 year = {1968},
 title = {Software engineering: Report on a conference ... Garmisch, Germany, 7th to 11th October 1968},
 address = {Brussels},
 publisher = {{NATO Scientific Affairs Div}},
 file = {nato1968e:Attachments/nato1968e.pdf:application/pdf}
}


@incollection{Nygaard.1982,
 author = {Nygaard, Kristen and Dahl, Ole-Johan},
 title = {The development of the SIMULA languages},
 pages = {439--480},
 publisher = {{Academic Press}},
 isbn = {0127450408},
 series = {ACM monograph series},
 editor = {Wexelblat, Richard L.},
 booktitle = {History of programming languages},
 year = {1982},
 address = {New York},
 doi = {10.1145/800025.1198392}
}


@misc{StackOverflow.04.11.2022,
 abstract = {Stack Overflow is the largest, most trusted online community for developers to learn, share​ ​their programming ​knowledge, and build their careers.},
 author = {{Stack Overflow}},
 year = {04.11.2022},
 title = {Stack Overflow - Where Developers Learn, Share, {\&} Build Careers},
 url = {https://stackoverflow.com/},
 urldate = {04.11.2022}
}


@misc{T4Tutorials.com.04.11.2022,
 abstract = {What is software reuse? Software reuse is a term used for developing the software by using the existing software components. Some of the components that can be$\ldots$},
 author = {T4Tutorials.com},
 year = {04.11.2022},
 title = {Software reuse and software reuse oriented software engineering | T4Tutorials.com},
 url = {https://t4tutorials.com/software-reuse-and-software-reuse-oriented-software-engineering/},
 urldate = {04.11.2022}
}


@article{Wasserman.2011,
 author = {Wasserman, Anthony I.},
 year = {2011},
 title = {How the Internet transformed the software industry},
 pages = {11--22},
 volume = {2},
 number = {1},
 issn = {1867-4828},
 journal = {Journal of Internet Services and Applications},
 doi = {10.1007/s13174-011-0019-x}
}


@book{Wexelblat.1982,
 year = {1982},
 title = {History of programming languages: Proceedings},
 address = {New York},
 edition = {[Nachdr.]},
 publisher = {{Academic Press}},
 isbn = {0127450408},
 series = {ACM monograph series},
 editor = {Wexelblat, Richard L.},
 doi = {10.1145/800025}
}


@misc{Wikipedia.2022,
 abstract = {In computer science, a library is a collection of non-volatile resources used by computer programs, often for software development. These may include configuration data, documentation, help data, message templates, pre-written code and subroutines, classes, values or type specifications. In IBM's OS/360 and its successors they are referred to as partitioned data sets.A library is also a collection of implementations of behavior, written in terms of a language, that has a well-defined interface by which the behavior is invoked. For instance, people who want to write a higher-level program can use a library to make system calls instead of implementing those system calls over and over again. In addition, the behavior is provided for reuse by multiple independent programs. A program invokes the library-provided behavior via a mechanism of the language. For example, in a simple imperative language such as C, the behavior in a library is invoked by using C's normal function-call. What distinguishes the call as being to a library function, versus being to another function in the same program, is the way that the code is organized in the system.Library code is organized in such a way that it can be used by multiple programs that have no connection to each other, while code that is part of a program is organized to be used only within that one program. This distinction can gain a hierarchical notion when a program grows large, such as a multi-million-line program. In that case, there may be internal libraries that are reused by independent sub-portions of the large program. The distinguishing feature is that a library is organized for the purposes of being reused by independent programs or sub-programs, and the user only needs to know the interface and not the internal details of the library.

The value of a library lies in the reuse of standardized program elements. When a program invokes a library, it gains the behavior implemented inside that library without having to implement that behavior itself. Libraries encourage the sharing of code in a modular fashion and ease the distribution of the code.

The behavior implemented by a library can be connected to the invoking program at different program lifecycle phases. If the code of the library is accessed during the build of the invoking program, then the library is called a static library. An alternative is to build the executable of the invoking program and distribute that, independently of the library implementation. The library behavior is connected after the executable has been invoked to be executed, either as part of the process of starting the execution, or in the middle of execution. In this case the library is called a dynamic library (loaded at runtime). A dynamic library can be loaded and linked when preparing a program for execution, by the linker. Alternatively, in the middle of execution, an application may explicitly request that a module be loaded.

Most compiled languages have a standard library, although programmers can also create their own custom libraries. Most modern software systems provide libraries that implement the majority of the system services. Such libraries have organized the services which a modern application requires. As such, most code used by modern applications is provided in these system libraries.},
 editor = {Wikipedia},
 year = {2022},
 title = {Library (computing)},
 url = {https://en.wikipedia.org/w/index.php?title=Library_(computing)&oldid=1109362116},
 urldate = {04.11.2022},
 file = {Wikipedia (Hg.) 2022 - Library computing:Attachments/Wikipedia (Hg.) 2022 - Library computing.pdf:application/pdf}
}


@article{WilliamB.FrakesandChristopherJ.Fox.,
 author = {{William B. Frakes and Christopher J. Fox}},
 title = {Modeling Reuse across the Software Life Cycle},
 volume = {1995},
 journal = {Software Engineering Guild, Sterling, VA},
 file = {Frakes und Fox 1995:Attachments/Frakes und Fox 1995.pdf:application/pdf}
}


@article{WilliamB.FrakesandChristopherJ.Fox.1996,
 author = {{William B. Frakes and Christopher J. Fox}},
 year = {1996},
 title = {Quality Improvement Using A Software Reuse Failure Modes Model},
 volume = {22},
 number = {4},
 journal = {IEEE TRANSACTIONS ON SOFTWARE ENGINEERING},
 file = {Frakes und Fox 1996 Quality{\_}improvement{\_}using{\_}a{\_}software{\_}reuse{\_}failure{\_}modes{\_}model:Attachments/Frakes und Fox 1996 Quality{\_}improvement{\_}using{\_}a{\_}software{\_}reuse{\_}failure{\_}modes{\_}model.pdf:application/pdf}
}


@misc{.12.10.2022,
 year = {12.10.2022},
 title = {Why Software Reuse has Failed and How to Make It Work for You},
 url = {https://www.dre.vanderbilt.edu/~schmidt/reuse-lessons.html},
 urldate = {12.10.2022}
}


@misc{.12.10.2022b,
 abstract = {In this tutorial, we are going to learn about the definition and advantages of software reuse in software engineering.},
 year = {12.10.2022},
 title = {Software Reuse: Definition and Advantages | Software Engineering},
 url = {https://www.includehelp.com/basics/software-reuse-definition-and-advantages-software-engineering.aspx},
 urldate = {12.10.2022}
}


@phdthesis{Bauer.2016,
 author = {Bauer, Veronika Maria},
 year = {2016},
 title = {Analysing and supporting software reuse in practice},
 address = {M{\"u}nchen},
 school = {{Universit{\"a}tsbibliothek der TU M{\"u}nchen}},
 type = {Dissertation}
}


@misc{codecentric.08.09.2020,
 abstract = {Mit jedem neuen Konzept in der Softwarearchitektur wird immer wieder Wiederverwendung als einer der wichtigsten Gewinne angepriesen.},
 author = {codecentric},
 year = {08.09.2020},
 title = {Softwarearchitektur: Der Mythos der Wiederverwendung},
 url = {https://www.codecentric.de/wissen/publikation/der-mythos-der-wiederverwendung},
 urldate = {12.10.2022}
}


@article{Krueger.,
 abstract = {(0360-0300) 24:2 0131-0183 (June 1992)},
 author = {Krueger},
 title = {Software reuse},
 url = {http://sunnyday.mit.edu/16.355/kruger.pdf},
 urldate = {12.10.2022},
 file = {Software reuse:Attachments/Software reuse.pdf:application/pdf}
}

@book{Bauer.2008,
 author = {Bauer, G{\"u}nther},
 year = {2008},
 title = {Architekturen f{\"u}r Web-Anwendungen: Eine praxisbezogene Konstruktions-Systematik},
 address = {Wiesbaden},
 edition = {1. Aufl.},
 publisher = {{Vieweg + Teubner in GWV Fachverlage GmbH}},
 isbn = {978-3-8348-0515-7}
}


@book{Starke.2020,
 abstract = {Software-Architekten m{\"u}ssen komplexe fachliche und technische Anforderungen an IT-Systeme umsetzen und diese Systeme durch nachvollziehbare Strukturen flexibel und erweiterbar gestalten. Dieser Praxisleitfaden zeigt Ihnen, wie Sie Software-Architekturen effektiv und systematisch entwickeln k{\"o}nnen. Der bekannte Software-Architekt Gernot Starke unterst{\"u}tzt Sie mit praktischen Tipps, Architekturmustern und seinen Erfahrungen. Er gibt Antworten auf zentrale Fragen: - Welche Aufgaben haben Software-Architekten? - Wie gehen Software-Architekten beim Entwurf vor? - Wie kommunizieren und dokumentieren Sie Software-Architekturen? - Wie helfen Architekturmuster und Architekturbausteine? - Wie bewerten Sie Software-Architekturen? - Wie behandeln Sie Persistenz, grafische Benutzeroberfl{\"a}chen, Gesch{\"a}ftsregeln, Integration, Verteilung, Sicherheit, Fehlerbehandlung, Workflow-Management und sonstige technische Konzepte? - Was m{\"u}ssen Software-Architekten {\"u}ber MDA/MDSD, UML 2 und arc42 wissen? - Welche Aufgaben nehmen Enterprise-IT-Architekten wahr?



Dr. Gernot Starke stellt sich seit vielen Jahren der Herausforderung, die Architektur gro{\ss}er Systeme effektiv zu gestalten. Zu seinen Kunden z{\"a}hlen mittlere und gro{\ss}e Unternehmen aus den Branchen Finanzdienstleistung, Logistik, Handel, Telekommunikation und dem {\"o}ffentlichen Bereich. Er ist Mitinitiator und -betreiber von arc42, Mitgr{\"u}nder des iSAQB e.V. sowie Fellow der innoQ.},
 author = {Starke, Gernot},
 year = {2020},
 title = {Effektive Softwarearchitekturen: Ein praktischer Leitfaden},
 keywords = {Softwarearchitektur},
 address = {M{\"u}nchen},
 edition = {9., {\"u}berarbeitete Auflage},
 publisher = {Hanser},
 isbn = {978-3-446-46376-9},
 series = {Hanser eLibrary},
 institution = {{Carl Hanser Verlag}},
 doi = {10.3139/9783446465893}
}


@book{Starke.2009,
 author = {Starke, Gernot and Hruschka, Peter},
 year = {2009},
 title = {Software-Architektur kompakt: - angemessen und zielorientiert},
 price = {Pb. : ca. sfr 20.50 (freier Pr.), ca. EUR 12.95},
 keywords = {Computer science;Software engineering},
 address = {Heidelberg},
 publisher = {{Spektrum Akademischer Verlag}},
 isbn = {978-3-8274-2093-0},
 series = {Kompakt-Reihe},
 file = {https://swbplus.bsz-bw.de/bsz306250314cov.jpg},
 file = {https://swbplus.bsz-bw.de/bsz306250314kap.htm},
 file = {https://swbplus.bsz-bw.de/bsz306250314inh.htm}
}


@book{Starke.2011,
 author = {Starke, Gernot and Hruschka, Peter},
 year = {2011},
 title = {Software-Architektur kompakt: - angemessen und zielorientiert},
 keywords = {Computer science;Software engineering},
 address = {Heidelberg},
 publisher = {{Spektrum Akademischer Verlag}},
 isbn = {978-3-8274-2093-0},
 series = {Kompakt-Reihe},
 file = {bsz306250314cov:\\\\swbplus.bsz-bw.de\\bsz306250314cov.jpg:jpg;bsz306250314inh:\\\\swbplus.bsz-bw.de\\bsz306250314inh.htm:htm;bsz306250314kap:\\\\swbplus.bsz-bw.de\\bsz306250314kap.htm:htm}
}

@book{Dowalil.2020,
 abstract = {MODULARE SOFTWAREARCHITEKTUR // - Lesen Sie Grundlegendes {\"u}ber die neue Schule der Softwarearchitektur - Nutzen Sie die konkreten Empfehlungen zum Bau langlebiger, weil modularer Enterprise- bzw. Makro-Architektur - Erfahren Sie, wie Sie Schritt f{\"u}r Schritt Ihr System zu einer modularen Architektur hin umbauen k{\"o}nnen - Lernen Sie die Prinzipien nachhaltiger und modularer Architektur anhand eines 16-teiligen Code-Tutorials kennen - Das 5C-Modell stellt eine Alternative zum Microservice-Hype dar und ist auch bei komplexen Architekturen anwendbar Die Softwarekrise h{\"a}lt die IT-Branche seit den 1960er-Jahren in Atem. Damals wurde heftig dar{\"u}ber debattiert, ob man nicht lieber auf die Verwendung des GOTO-Schl{\"u}sselworts und x-beliebiger Spr{\"u}nge im Code verzichten sollte. Mit der zunehmenden Leistungsf{\"a}higkeit der Hardware wurde auch die darauf laufende Software immer komplexer, und man suchte nach Rezepten, um deren Wartbarkeit zu verbessern. Diese Entwicklung ist bis heute nicht abgeschlossen. Die digitale Transformation der Gesellschaft bringt f{\"u}r bestehende IT-Landschaften neue Herausforderungen mit sich. Enterprise-Architekturen, die sich oft durch ungeplant entstandene Komplexit{\"a}t auszeichnen, sollen pl{\"o}tzlich weiterwachsen. Da die klassischen Muster der Enterprise-Architektur dabei oft versagen, werden zurzeit neue Prinzipien und Muster entwickelt, welche genau diese Komplexit{\"a}t in geordnete Bahnen lenken sollen. Dieses Buch behandelt diese Themen und stellt den Bezug zu den guten alten Mustern und Prinzipien des Softwaredesigns her. AUS DEM INHALT // {\"U}ber Softwarearchitektur/Migration von Legacy-Systemen/Domain Driven Design/Muster modularer Mikro-Architektur/Muster modularer Makro-Architektur bzw. langlebige Enterprise-Architektur/Monolithen, Microservices und Alternativen/Antipattern und Pitfalls modularer Architektur und wie man diese vermeidet/Umsetzung modularer Architektur in komplexen Organisationen



Herbert Dowalil ist seit vielen Jahren als Softwareentwickler, -architekt, Trainer und inzwischen auch als Autor t{\"a}tig. Dabei besch{\"a}ftigt er sich mit der Frage, wie man durch den Entwurf effizienter Strukturen langfristig Produktivit{\"a}t und Flexibilit{\"a}t sicherstellt. Sein Hauptaugenmerk gilt dabei einer der Schwachstellen der IT-Branche, n{\"a}mlich der modularen Enterprise- bzw. Makro-Architektur.},
 author = {Dowalil, Herbert},
 year = {2020},
 title = {Modulare Softwarearchitektur: Nachhaltiger Entwurf durch Microservices, Modulithen und SOA 2.0},
 keywords = {Domain-Driven-Design;Microservice;Softwarearchitektur;Software-Architektur;Softwareentwicklung;Software-Entwicklung},
 address = {M{\"u}nchen},
 edition = {2., {\"u}berarbeitete Auflage},
 publisher = {Hanser},
 isbn = {978-3-446-46377-6},
 series = {Hanser eLibrary},
 institution = {{Carl Hanser Verlag}},
 doi = {10.3139/9783446465343}
}


@book{Goll.2011,
 abstract = {Der Autor des vorliegenden Buches wendet sich in 1. Linie an Studierende der Informatik an Hochschulen und Softwareentwickler in der Praxis. Er will deutlich machen, dass es sich bei der Softwareentwicklung um einen weitestgehend standardisierten, methodischen Entwicklungsprozess handelt. In seinem Buch geht er ausf{\"u}hrlich auf die einzelnen Schritte der Softwareentwicklung ein und stellt f{\"u}r jeden Schritt bew{\"a}hrte Entwurfs- und Architekturmuster vor, die als Bausteine verwendet werden k{\"o}nnen. Lauff{\"a}hige Beispiele erm{\"o}glichen eine gute Pr{\"u}fung, inwieweit diese Muster f{\"u}r eigene Projekte einsetzbar sind. Ein besonderer Schwerpunkt liegt beim Testen fertiger Projekte. Auf speziellere Fragen wie das Gestalten von Benutzeroberfl{\"a}chen oder Dialogtechniken geht das Buch kaum ein. Didaktisch sehr gut gestaltet: {\textquotedbl}Lernk{\"a}stchen{\textquotedbl} erm{\"o}glichen eine gezielte Wiederholung des Stoffes; {\textquotedbl}Warnk{\"a}stchen{\textquotedbl} geben Hinweise zur Vermeidung typischer schwerwiegender Anf{\"a}ngerfehler. Viele einfachere {\"U}bungsaufgaben am Ende der einzelnen Kapitel. - Gut einsetzbar neben dem umfassenden Basiswerk von T. Posch (ID-G 25/11). (3)},
 author = {Goll, Joachim},
 year = {2011},
 title = {Methoden und Architekturen der Softwaretechnik},
 keywords = {Computer software;Software architecture;Software engineering},
 address = {Wiesbaden},
 edition = {1. Aufl.},
 publisher = {{Vieweg + Teubner}},
 isbn = {978-3-8348-1578-1},
 series = {Studium},
 file = {04:\\\\d-nb.info\\1010546481\\04:}
}


@book{Goll.2014,
 abstract = {Architekturen von Softwaresystemen sollen einfach erweiterbar und weitestgehend standardisiert sein, damit die Entwickler sich leicht {\"u}ber Architekturen austauschen k{\"o}nnen. F{\"u}r den objektorientierten Entwurf haben sich zahlreiche wertvolle Architektur- und Entwurfsmuster herausgebildet. Diese Muster basieren auf objektorientier­­ten Prinzipien wie dem Prinzip der Dependency Inversion. Daher werden zuerst die wichtig­sten objektorientierten Prinzipien erkl{\"a}rt. Anschlie{\ss}end wird gezeigt, wie diese objektorientierten Prinzipien in den verschie­denen Architektur- und Entwurfs­mustern umgesetzt werden. Alle vorgestellten Mus­ter werden durch lauff{\"a}hige Bei­spiele in Java illustriert. ~ Der Inhalt Prinzipien f{\"u}r den objektorientierten Entwurf: ~Abstraktion, Kapselung und Information Hiding - Separation of Concerns und das Single Responsibility-Prinzip - Interface Segregation-Prinzip - Loose Coupling - Liskovsches Substitutionsprinzip - Design by Contract - Open-Closed-Prinzip - Dependency Inversion-Prinzip - Softwarearchitekturen: Definition des Begriffs Softwarearchitektur - Rolle des Softwarearchitekten - Qualit{\"a}ten einer Softwarearchitektur - Referenzarchitekturen - Aufga­ben und Sichten bei der Konzeption einer Softwarearchitektur - Muster beim Softwareentwurf: Einsatz~und Eigenschaften von Mustern - Abgren­zung zwischen Architekturmustern, Entwurfsmustern und Idiomen - Schema f{\"u}r die Beschreibung von Entwurfs- und Architekturmustern - Objektorientierte Entwurfsmuster: Klassifikation von Entwurfsmustern - Die Struk­turmuster Adapter, Br{\"u}cke, Dekorierer, Fassade, Kompositum und Proxy - Die Verhaltensmuster Schablonenmethode, Befehl, Beobachter, Strategie, Vermittler, Zu­stand, Rolle, Besucher und Iterator - Die Erzeugungsmuster Fabrikmethode, Ab­strak­te Fabrik, Singleton und Objektpool - Architekturmuster: Layers, Pipes and Filters, Plug-in, Broker, Service-Oriented Ar­chitecture, Model-View-Controller ~ Die Zielgruppen Studierende der Informatik und der ingenieurswissenschaftlichen Disziplinen Berufliche Umsteiger und Entwickler in der Praxis Der Autor Professor Dr. Joachim Goll lehrt und forscht an der Hochschule Esslingen},
 author = {Goll, Joachim},
 year = {2014},
 title = {Architektur- und Entwurfsmuster der Softwaretechnik: Mit lauff{\"a}higen Beispielen in Java},
 keywords = {Computer science;Software engineering},
 address = {Wiesbaden},
 edition = {2., aktual. Aufl.},
 publisher = {{Springer Vieweg}},
 isbn = {978-3-658-05531-8},
 doi = {10.1007/978-3-658-05532-5}
}


@book{Tremp.2021,
 abstract = {Einf{\"u}hrung in die Softwarearchitektur -- Serviceorientierte Architektur (SOA) -- Mehrschichtige Architektur -- Flexible Architektur -- Clientseitige Architektur -- Serverseitige Architektur -- Anwendungsintegrationsarchitektur.



Das Lehrbuch f{\"u}hrt schrittweise in die faszinierende Welt der modernen verteilten Softwaresysteme ein. Dabei beginnt die Reise mit {\"U}berlegungen zu den T{\"a}tigkeiten des Softwarearchitekten. Weiter geht es zur Modellierung von serviceorientierten Mehrschichtenarchitekturen sowie deren technischer Umsetzung in den einzelnen Schichten. Dabei besch{\"a}ftigt sich das Buch mit aktuellen Technologien wie z. B. Microservices, SPA, PWA, node.js, .NET, JEE und vieles mehr. Ausf{\"u}hrungen zur organisationsinternen sowie -{\"u}bergreifenden Anwendungsintegration auf der Pr{\"a}sentations-, Applikations- und Datenebene runden die Reise ab. Ein durchgehendes anschauliches Beispiel zur Illustration der theoretischen Ausf{\"u}hrungen sowie fallstudienbezogene Aufgaben bieten die M{\"o}glichkeit der unmittelbaren Anwendung des Gelernten. Der Inhalt Einf{\"u}hrung in die Softwarearchitektur Serviceorientierte Architektur (SOA) Mehrschichtige Architektur Flexible Architektur Clientseitige Architektur Serverseitige Architektur Anwendungsintegrationsarchitektur Die Zielgruppen Studierende und Dozierende im Thema Software Engineering und Softwarearchitektur Praktiker*innen, welche sich einen {\"U}berblick {\"u}ber die aktuellen Softwarearchitekturen verschaffen wollen Der Autor Hansruedi Tremp ist Dozent und wissenschaftlicher Mitarbeiter am IPM (Institut f{\"u}r Informations- und Prozessmanagement) der OST Fachhochschule Ostschweiz in St. Gallen (vormals FHS St. Gallen). Seine langj{\"a}hrigen Softwareentwicklungs- und Lehrt{\"a}tigkeiten gehen {\"u}ber Projektleitung, Requirements Engineering, objektorientierte Programmierung, Softwareentwicklung von serverlosen Applikationen in der Cloud bis hin zur Softwarearchitektur.},
 author = {Tremp, Hansruedi},
 year = {2021},
 title = {Architekturen Verteilter Softwaresysteme: SOA {\&} Microservices - Mehrschichtenarchitekturen - Anwendungsintegration},
 keywords = {Computer organization;Software engineering},
 address = {Wiesbaden},
 edition = {1st ed. 2021},
 publisher = {{Springer Fachmedien Wiesbaden} and {Imprint Springer Vieweg}},
 isbn = {978-3-658-33178-8},
 series = {Springer eBook Collection},
 doi = {10.1007/978-3-658-33179-5}
}

@book{Appelrath.2012,
 author = {Appelrath, Hans-J{\"u}rgen},
 year = {2012},
 title = {IT-Architekturentwicklung im Smart Grid: Perspektiven f{\"u}r eine sichere markt- und standardbasierte Integration erneuerbarer Energien},
 price = {Gb. : EUR 89.95 (DE), EUR 92.50 (AT), sfr 112.00 (freier Pr.)},
 address = {Berlin and Heidelberg},
 edition = {1. Aufl.},
 publisher = {{Springer Gabler}},
 isbn = {978-3-642-29208-8},
 file = {http://deposit.d-nb.de/cgi-bin/dokserv?id=4043954&prov=M&dok_var=1&dok_ext=htm},
 file = {http://d-nb.info/102253405x/04},
 file = {https://swbplus.bsz-bw.de/bsz369389301cov.jpg}
}

@book{Goll.2011,
 author = {Goll, Joachim},
 year = {2011},
 title = {Methoden und Architekturen der Softwaretechnik},
 address = {Wiesbaden},
 publisher = {Vieweg+Teubner},
 isbn = {3834881643},
 series = {Studium}
}

@book{Martin.2009,
 author = {Martin, Robert C.},
 year = {2009},
 title = {Clean Code: Refactoring, Patterns, Testen und Techniken f{\"u}r sauberen Code},
 keywords = {Computer software;Entwurfsmuster;html;Java;Logik;Programmiersprache C++;Programmiertechnik;Programmierung;Reliability;Ruby;Software reengineering;Software refractoring;Software-Entwicklung;Unified Modeling Language (UML)},
 address = {Frechen and Hamburg},
 edition = {Deutsche Ausgabe, 1. Auflage},
 publisher = {mitp},
 isbn = {978-3-8266-9638-1},
 series = {mitp Professional},
 file = {https://content-select.com/portal/media/cover_image/5c85864b-fe70-4252-afa0-6037b0dd2d03/500}
}

@book{Roth.2021,
 author = {Roth, Stephan},
 year = {2021},
 title = {Clean C++20: Sustainable Software Development Patterns and Best Practices},
 address = {New York},
 edition = {Second edition},
 publisher = {Apress},
 isbn = {978-1-4842-5948-1}
}

@book{Kapil.2019,
 abstract = {Discover the right way to code in Python. This book provides the tips and techniques you need to produce error-free and eloquent Python projects. Your journey to better code starts with understanding the importance of formatting and documenting your code for maximum readability, utilizing built-in data structures and Python dictionary for improved maintainability, and working with modules and meta-classes to effectively organize your code. You will then dive deep into the new features of the Python language and learn how to effectively utilize them. Next, you will decode key concepts such as asynchronous programming, Python data types, type hinting, and path handling. Learn tips to debug and conduct unit and integration tests in your Python code to ensure your code is ready for production. The final leg of your learning journey equips you with essential tools for version management, managing live code, and intelligent code completion. After reading and using this book, you will be proficient in writing clean Python code and successfully apply these principles to your own Python projects. What You'll Learn Use the right expressions and statements in your Python code Create and assess Python Dictionary Work with advanced data structures in Python Write better modules, classes, functions, and metaclasses Start writing asynchronous Python immediately Discover new features in Python},
 author = {Kapil, Sunil},
 year = {2019},
 title = {Clean Python: Elegant Coding in Python},
 keywords = {Computer programming;Computer science;Programming languages (Electronic computers);Python;Python (Computer program language)},
 address = {New York},
 publisher = {Apress},
 isbn = {978-1-4842-4878-2},
 series = {Springer eBook Collection},
 doi = {10.1007/978-1-4842-4878-2}
}


